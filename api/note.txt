[255, 255, 255, 255, 0, 0, 168, 0, 10, 1]


def insert_str(string, str_to_insert, index):
    return string[:index] + str_to_insert + string[index:]

# hex into spaced & upper string
def bytes_to_hex_str(bytesinput):
    stroutput = bytesinput.hex()
    for i in range(int(len(str(bytesinput.hex()))/2-1)):
        stroutput = insert_str(stroutput, " ", 3*i+2)
    stroutput = stroutput.upper()
    return stroutput


FF FF FF FF 00 00 A8 00 0A 01



6 to 60 -> 100 to 1000

data [0] = (byte)(step>>8);
data [1] = (byte)(step&0x000000FF);




1000: 2초에 1바퀴 -> 1/2 rps
900: 4초에 1바퀴 -> 1/4 rps
800: 6초에 1바퀴 -> 1/6 rps
700: 8초
600: 10초
500: 12초
400: 14초
300: 16초
200: 18초
100: 20초 => (-x/50+22)초에 1바퀴 -> 1/(-x/50+22) rps -> 60/(-x/50+22) rpm

-1000: 2초에 -1바퀴 -> -1/2rps
-100: 20초 -> (x/50+22)초에 -1바퀴 -> -1/(x/50+22) rps -> -60/(x/50+22) rpm


RPM = 60/(-SPS/50+22)
RPM/60 = 1/(-SPS/50+22)
60/RPM = -SPS/50+22
60/RPM-22 = -SPS/50
SPS/50 = -60/RPM+22
SPS = 50*(-60/RPM+22)



1초 : x바퀴 = 1분 : y바퀴

x = y/60


RPM = -60/(SPS/50+22)
-RPM/60 = 1/(SPS/50+22)
-60/RPM = SPS/50+22
-60/RPM-22 = SPS/50
SPS/50 = -60/RPM-22
SPS = 50*(-60/RPM-22)







방향:
1) 뒤에서 쓰레드 -> 시리얼 연결: 끊어지면 알아서 자동으로 연결함.
2) 로봇 자동 연결? 또는 수동 연결? -> 현재는 쓰레드에서 자동 연결. 문제가 있음.
3) 






문제:
1) 포트 찾는 바이트코드를 보낼 때 시리얼 연결을 했었다가 
115200으로 보내면 다시 응답이 안 옴.
2) 완전 연결(1개면 1개, 2개면 2개까지)이 됐다가 끊어지고 
로봇이랑 다시 연결하려면 시리얼 연결을 끊었다가 다시 해야함.



파이썬 상속: parent와 child 변수는 동기화됨.
parent변수와 child 변수의 이름이 같으면 전달됐을 때 id(포인터)가 동일함. 따라서 완전히 동기화.
parent변수와 child 변수의 이름이 다르면 전달됐을 때 변경되기 전까지는 id가 동일하지만,
변경되면 id가 둘이 달라짐. 
함수는 동기화 안됨. 밖에서는 덮어 씌어 짐. 안에서 따로 불러올 수 있음.

다중 상속: parent1, parent2 클래스에 같은 이름의 함수가 있으면, 먼저 상속한 함수를 불러 옴.
예) class childClass(parentClass1, parentClass2)
이면 parentClass1의 함수를 불러옴,







1개만 연결 -> 끊어짐 -> 모든 상황에서 full connection 끊김
2개 이상 -> 마스터 끊어짐 -> full connection이 아닐 때 -> 리셋 
			  -> full connection일 때 -> 리셋
	 -> 슬레이브 끊어짐 -> full connection일 때 -> 리셋
			    -> full connection이 아닐 때 -> 리셋 X


schedule은 한 번 설정하면 계속 유지됨. 다시 schedule을 쓰면 이전 것은 지워짐.
resume이 끝나면 pause 상태로 리셋. 스케줄은 유지.
pause, resume은 continue와 point를 하면 마지막으로 한 것에 영향을 받음.





스케줄: 1개 연결하면 반응이 안 옴
2개 이상 연결하면 1번에 대한 반응만 옴
-> 2개 이상 연결해서 2번만 스케줄을 실행시키면(포인트) 반응이 안 옴.
-> 2개 이상 연결해서 모두 스케줄 실행시키면(포인트 등) 1번에 대한 반응만 옴.






play_motor_schedule: set한 스케줄을 플레이함
play_paused_motor: pause시킨 것들을 플레이함.





컨티뉴, 스텝

스케줄

포인트




pause list: all인 경우
-> 길이가 1이면 pass
-> 길이가 1이 아니면: 
	-> 길이가 큐브ID와 같으면: 
		-> 원소가 전부 같으면 하나로 합침
		-> 다르면 에러
	-> 다르면 에러
all이 아닌 경우
-> 길이가 1이면 늘림
-> 길이가 1이 아니면:
	-> 길이가 큐브ID와 갈으면 패스
	-> 다르면 에러


cubeID, pause, speed

경우: cubeID: all, 다 따로, 따로인데 전부 있음
pause: 1개, 또는 cubeID에 맞게, 또는 cubeID 맞는데 전부 같음
speed: 1개, 또는 cubeID에 맞게, 또는 cubeID 맞는데 전부 같음

가능한 것: [all, 1개, 1개] : 바이트 1줄
[all, cubeID, 1개]: 바이트 여러줄
[all, 1개, cubeID]: 바이트 여러줄
[all, cubeID, cubeID]: 바이트 여러줄

[all, cubeID(같음), cubeID(같음)] = [all, 1개, 1개]: 바이트 1줄

[따로, 1개, 1개]: 바이트 여러줄
[따로인데 전부 있음, 1개, 1개] = [all, 1개, 1개]: 바이트 1줄
[따로인데 전부 있음, cubeID(같음), cubeID(같음)] = [all, 1개, 1개]: 바이트 1줄
[따로, cubeID, 1개]: 바이트 여러줄
[따로, 1개, cubeID]: 바이트 여러줄
[따로, cubeID, cubeID]: 바이트 여러줄






cube ID: all인 경우
all인데 speed의 모든 원소가 같으면 스피드를 하나로 만들어야 함.

-> speed 길이가 connection number와 같음: cube ID를 늘려줘야 함
-> speed 길이가 1: 패스


all이 아닌 경우
all이 아닌데 speed 길이가 1: 스피드를 늘림





스케줄: 
[1] X
[1, 2, 3] X
[[1, 2, 3]]
[[1], [2], [3]]
[[1, 2, 3], [2, 3, 4], [5, 6, 7]]
[[1, 2, 3], 4, [5, 6, 7], 8] X

안이 전부 숫자이면 1개, 또는 큐브 숫자X
안이 전부 리스트이면 1개, 또는 큐브 숫자
안이 숫자, 또는 리스트이면 1개, 또는 큐브 숫자X


안이 전부 리스트로 하기. 1개, 또는 큐브 숫자.






스피드 [[1, 2, 3, 4], [2, 3, 4]]: non-sync
스피드 [[1, 2, 3, 4], [2, 3, 4, 5]]: sync

스텝 [[3, 4, 5, 6]]
타임 [[2, 3, 4, 5]]

sync인 경우: 스피드끼리 길이가 같아야 함.
스텝끼리 길이가 같아야 함.
스피드와 스텝도 길이가 같아야 함.

non-sync인 경우: 스피드끼리 길이가 달라도 됨.
스텝끼리 길이가 달라도 됨.
근데 스피드, 스텝끼리는 길이가 같아야 함.



rpm, 사이클: 0이면 초: 사이클/2
sps, 스텝: 0이면 ms

rpm, 스텝: 0이면 ms
sps, 사이클: 0이면 초: 사이클/2





sync 
스피드: 1000SPS, 2000스텝: 2초
	1000SPS, 1000스텝: 1초
2000스텝 = 1사이클


STEP/SPS = 초 XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX아님

x1 스텝 y1 SPS
x2 스텝 y2 SPS



time + step 모드
time + schedule 모드


time step speed




스텝: [1, 4, 5]
스케줄: [[1, 4, 5]]



1번 큐브 타임: [1.1, 1.2, 1.3, 1.2]
2번 큐브 타임: [1.2, 1.3, 1.4, 1.3]
3번 큐브 타임: [1.3, 1.4, 1.1, 1.3]
offset: 1-2, 1-3
[-0.1, -0.1, -0.1, -0.1], [-0.1, -0.1, 0.3, 0]
2번: -0.4, 3번: 0.1

=> [1.1, 1.2, 1.3, 1.2, 0]
[1.2, 1.3, 1.4, 1.3, -0.4]
[1.3, 1.4, 1.1, 1.3, 0.1]

큐브 3개, 스케줄 4개
speed: [[1, 2, 3, 4], [4, 5, 6, 7], [4, 5, 6, 7]]
step: [[4, 5, 6, 7], [7, 8, 9, 10], [3, 5, 7, 9]]




time, speed: step = speed*time
time, step: speed = step/time
step +- 가능. step=0이면 sleep.





1 RPM = 1 rot/min = 1/60 rot/sec = 1/60 RPS

x RPM = x/60 RPS

3 RPM = 1/20 RPS : 최저
30 RPM = 1/2 RPS : 최대



10 cycle

1/20 RPS: 200초





############################################
[1, 2]

speed = [[20, 30, -30], [20 ,30 ,10]]
time = [[2, 3, 2]]


time, step
time, speed



#############################################



x = [[1, 2, 3]]*3
>> x
[[1, 2, 3], [1, 2, 3], [1, 2, 3]]
>> x[0][1] = 4
>> x
[[1, 4, 3], [1, 4, 3], [1, 4, 3]]





https://suwoni-codelab.com/python%20%EA%B8%B0%EB%B3%B8/2018/03/02/Python-Basic-copy/


60 rpm ->








[[[1, 3], [2, 4], [5, 6]], [[3, 4], [4, 5], [7, 8]]]
 -> [[1, 2, 5], [3, 4, 6]],   [[3, 4, 7], [4, 5, 8]]
([1번 큐브 시작, 2번 큐브 시작], [1번 큐브 끝, 2번 큐브 끝])

[1, 2]


cube_id = [1, 2, 3]

servo_schedule= [[90, 180, 0], [180, 90], [0, 90]]

duration = [1] -> [[1, 1, 1], [1, 1], [1, 1]]
-> speed = [[0, 0, 0], [0, 0], [0, 0]], RPM
-> step = [[1, 1, 1], [1, 1], [1, 1]]], CYCLE

duration = [[1, 2, 3], [4, 5], [6, 7]]

servo_schedule = [[0]] ->(expand) [[0], [0], [0]]
servo_schedule = [[0, 180, 0]] -> (expand) [[0, 180, 0], [0, 180, 0], [0, 180, 0]]

duration = [[1, 2]] -> error


cube = [1, 2]

servo_list = [[0, 1, 2]]

1) duration = [[1]] -> [[1, 1, 1]]*run_number
3) duration = [[1, 2, 3]] -> [[1, 2, 3]]*run_number
4) duration = [[1, 2, 3], [4, 5, 6]] -> pass




(s*100)/8 ~ (s*100)/160
0.08< s <1.6	    1.6 < s < 320

200~1

s*20000 ~ s*100
32000~160



[0, 0, 0, 0, 0, 0, 0, 0] -> None
[1, 0, 0, 0, 0, 0, 0, 0] -> (0,0)
[2, 0, 0, 0, 0, 0, 0, 0] -> (1,0)
[3, 0, 0, 0, 0, 0, 0, 0] -> (0,0), (1,1)
[4, 0, 0, 0, 0, 0, 0, 0] -> (2,0)
[5, 0, 0, 0, 0, 0, 0, 0] -> (0,0), (2,0)
[6, 0, 0, 0, 0, 0, 0, 0] -> (1,0), (2,0)

[0, 1, 0, 0, 0, 0, 0, 0] -> (0, 7)
[0, 2, 0, 0, 0, 0, 0, 0] -> (1, 7)
[0, 0, 1, 0, 0, 0, 0, 0] -> (0, 6)
[0, 0, 0, 0, 0, 0, 0, 1] -> (0, 1)

(8-j)%8

0 7 6 5 4 3 2 1

1 2 3 4 5 6 7 0

(j+1)%8



[[0, 0, 0, 0, 0, 0, 0, 0], -> 0
[0, 0, 0, 0, 0, 0, 1, 0], -> 128
[1, 1, 1, 1, 1, 0, 1, 0], -> 250
[0, 0, 0, 1, 0, 0, 1, 0],
[0, 0, 1, 1, 0, 0, 1, 1],
[0, 1, 1, 0, 0, 0, 1, 0],
[1, 1, 0, 0, 0, 0, 1, 0],
[0, 0, 0, 0, 0, 0, 1, 0]]












